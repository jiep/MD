points = 200
x <- seq(-2*pi, 2*pi, length = points)
y <- x*sin(x)
plot(x,y, type='l')
points = 200
x <- seq(-2*pi, 2*pi, length = points)
y <- x*sin(x)
plot(x,y)
linear.model <- lm(y~x)
summary(linear.model)
plot(linear.model)
summary(linear.model)
plot(linear.model)
# Ajustamos los datos segÃºn un modelo linear
library(nnet)
nnet(y~x, rang=0.1, size=8, linout=T, maxit=1000)
install.packages("neuralnet")
library(neuralnet)
neuralnet(y~x, hidden = 8, rep=1)
neural(y~x, rang=0.1, size=5, linout=T, maxit=1000)
neuralnet(y~x, rang=0.1, size=5, linout=T, maxit=1000)
fit.nn <- nnet(x,y, rang=0.1, size=5, linout=T, maxit=10000)
fit.nn
fit.nn$value
min.nn(x,y)
min.nn <- function(x,y, iter=10){
min_value <- 10e6 # Infinito
actual_fit <- NULL
for(i in seq(1, iter)){
fit.nn <- nnet(x,y, rang=0.1, size=5, linout=T, maxit=10000)
if(fit.nn$value < min_value){
min_value <- fit.nn$value
actual_fit <- fit.nn
}
}
return(actual_fit)
}
min.nn(x,y)
min=min.nn(x,y)
min
# el comando nnet y devuelve el ajuste  que tenga el error menor tenga
min.nn <- function(x,y, iter=10){
min_value <- 10e6 # Infinito
actual_fit <- NULL
for(i in seq(1, iter)){
fit.nn <- nnet(x,y, rang=0.1, size=5, linout=T, maxit=10000, trace = FALSE)
if(fit.nn$value < min_value){
min_value <- fit.nn$value
actual_fit <- fit.nn
}
}
return(actual_fit)
}
min.nn(x,y)
min.nn <- function(x,y, iter=10){
min_value <- 10e6 # Infinito
actual_fit <- NULL
for(i in seq(1, iter)){
fit.nn <- nnet(x,y, rang=0.1, size=5, linout=T, maxit=10000, trace = FALSE)
if(fit.nn$value < min_value){
min_value <- fit.nn$value
cat(min_value)
actual_fit <- fit.nn
}
}
return(actual_fit)
}
min=min.nn(x,y)
min.nn <- function(x,y, iter=10){
min_value <- 10e6 # Infinito
actual_fit <- NULL
for(i in seq(1, iter)){
fit.nn <- nnet(x,y, rang=0.1, size=5, linout=T, maxit=10000, trace = FALSE)
if(fit.nn$value < min_value){
min_value <- fit.nn$value
cat(min_value, '\n')
actual_fit <- fit.nn
}
}
return(actual_fit)
}
min=min.nn(x,y)
min$value
min.nn <- function(x,y, iter=10){
min_value <- 10e6 # Infinito
actual_fit <- NULL
for(i in seq(1, iter)){
fit.nn <- nnet(x,y, rang=0.1, size=5, linout=T, maxit=10000, trace = FALSE)
cat(min_value, '\n')
if(fit.nn$value < min_value){
min_value <- fit.nn$value
actual_fit <- fit.nn
}
}
return(actual_fit)
}
min=min.nn(x,y)
min.nn <- function(x,y, iter=10){
min_value <- 10e6 # Infinito
actual_fit <- NULL
for(i in seq(1, iter)){
fit.nn <- nnet(x,y, rang=0.1, size=5, linout=T, maxit=10000, trace = FALSE)
cat(fit.nn$value, '\n')
if(fit.nn$value < min_value){
min_value <- fit.nn$value
actual_fit <- fit.nn
}
}
return(actual_fit)
}
min=min.nn(x,y)
predict(min, as.matrix(x))
plot(x,predict.nn)
predict.nn<-predict(min, x)
predict.nn
predict.nn<-predict(min, as.matrix(x))
predict.nn
matplot(x,predict.nn)
matplot(x,predict.nn)
par()
plot(x,y)
matplot(x,predict.nn)
par()
plot(x,y)
neuralnet(y~x, cbind(x,y), hidden=5, rep=1)
